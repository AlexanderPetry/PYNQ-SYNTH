#include "peripheral.h"

Audio_Driver::Audio_Driver(){
	int Status;
	IicConfig(XPAR_XIICPS_0_DEVICE_ID);
	AudioPllConfig();
	AudioConfigureJacks();
	LineinLineoutConfig();

	 XScuTimer Scu_Timer;
	 XScuTimer_Config *Scu_ConfigPtr;
	 XScuGic IntcInstance;

	 Scu_ConfigPtr = XScuTimer_LookupConfig(XPAR_PS7_SCUTIMER_0_DEVICE_ID);
	 Status = XScuTimer_CfgInitialize(&Scu_Timer, Scu_ConfigPtr, Scu_ConfigPtr->BaseAddr);
	 Status = Timer_Intr_Setup(&IntcInstance, &Scu_Timer, XPS_SCU_TMR_INT_ID);
	 XScuTimer_LoadTimer(&Scu_Timer,(XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ / 2)/(SAMPLE_RATE));
	 XScuTimer_EnableAutoReload(&Scu_Timer);
	 XScuTimer_Start(&Scu_Timer);
}

static int
Audio_Driver::Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId)
{
	int Status;
	XScuGic_Config *IntcConfig;
	IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
	Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
	// Step 1: Interrupt Setup
	Xil_ExceptionInit();
	// Step 2: Interrupt Setup
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler,IntcInstancePtr);
	// Step 3: Interrupt Setup
	Status = XScuGic_Connect(IntcInstancePtr, TimerIntrId, (Xil_ExceptionHandler)Timer_ISR, (void *)TimerInstancePtr);
	// Step 4: Interrupt Setup
	XScuGic_Enable(IntcInstancePtr, TimerIntrId);
	// Step 5:
	XScuTimer_EnableInterrupt(TimerInstancePtr);
	// Step 6: Interrupt Setup
	Xil_ExceptionEnable();
	return XST_SUCCESS;
}

// Timer_ISR for sine generation (no LUT, our processor seems to be fast enough ;-) )
static void
Audio_Driver::Timer_ISR(void * CallBackRef)
{
	const float32_t frequency = 2222; //audio frequency to generate
	const float32_t theta_increment = 2 * PI * frequency / SAMPLE_RATE;
	static float32_t theta = 0.0f;

	XScuTimer *TimerInstancePtr = (XScuTimer *) CallBackRef;
	XScuTimer_ClearInterruptStatus(TimerInstancePtr);

	theta += theta_increment ;
	if ( theta > 2* PI)
		theta -= 2* PI;

	//float sine_value = sinf(theta); // non CMSIS function comment out for using
	float32_t sine_value = arm_sin_f32(theta); // CMSIS function
	uint32_t scaled_value = (uint32_t)(((sine_value + 1.0f) * 0.5f) * UINT_SCALED_MAX_VALUE);
	Xil_Out32(I2S_DATA_TX_R_REG, scaled_value);
}

UART::UART(){
	XUartPs_Config *Config = XUartPs_LookupConfig(XPAR_XUARTPS_0_DEVICE_ID);
	XUartPs_CfgInitialize(&Uart_Ps, Config, Config->BaseAddress);
	XUartPs_SetBaudRate(&Uart_Ps, 115200);
}

Rotary_enc::Rotary_enc(){
	XGpio_Initialize(&rotary, XPAR_AXI_GPIO_0_DEVICE_ID);
	XGpio_SetDataDirection(&rotary, 1, 0xFFFFFFFF);  // all inputs
	PS = Getvalue();
}

Rotary_enc::RE_STATE
Rotary_enc::GetSate(){
	u32 CS = Getvalue();
	RE_STATE state{IDLE};

	if(CS == 0b111){
	   switch(PS){
	       case 0b110:
	        	if(debounce){
	        			debounce = 0;
	        	}else {
	        		debounce= 1;
	        		xil_printf("button\r\n");
	        		state = BUTTON;
	        	}
				break;

			case 0b011:
				I32increment(counter,1);
				xil_printf("rechts, %d\r\n",counter);
				state = RIGHT;
				break;

			case 0b101:
				I32decrement(counter,1);
				xil_printf("links, %d\r\n",counter);
				state = LEFT;
				break;

			default:
				break;
	        }
	}
	PS = CS;

	return state;
}
