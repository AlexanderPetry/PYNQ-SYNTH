#include "voice.hpp"

void voice::play() {
    active = true;
    env.state = EnvState::Attack;
    env.amplitude = 0.0f;
}

void voice::addSignal(signal s) {
    signals.push_back(s);
}

void voice::clear() {
    signals.clear();
}

void voice::stop() {
    active = false;
    signals.clear();
    env.state = EnvState::Release;
}

bool voice::isActive() const {
	return env.state != EnvState::Idle;
}

float voice::nextSample(float globalPhase, float baseFreq) {
    if (!active) return 0.0f;

    float sum = 0.0f;
    for (auto& s : signals) {
        sum += s.nextSample( globalPhase,  baseFreq);
    }
    return sum* env.amplitude;
}

void voice::updateEnvelope(float deltaTime) {
    switch (env.state) {
        case EnvState::Attack:
            env.amplitude += deltaTime / env.attackTime;
            if (env.amplitude >= 1.0f) {
                env.amplitude = 1.0f;
                env.state = EnvState::Sustain;
            }
            break;
        case EnvState::Release:
            env.amplitude -= deltaTime / env.releaseTime;
            if (env.amplitude <= 0.0f) {
                env.amplitude = 0.0f;
                env.state = EnvState::Idle;
            }
            break;
        case EnvState::Idle:
        case EnvState::Sustain:
        case EnvState::Decay:
            break;
    }
}
