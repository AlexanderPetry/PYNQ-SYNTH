#include "peripheral.h"
namespace audio{

	unsigned long Audio_Driver::u32DataL = 0;
	unsigned long Audio_Driver::u32DataR = 0;

	Audio_Driver::Audio_Driver(){
		int Status;
		IicConfig(XPAR_XIICPS_0_DEVICE_ID);
		AudioPllConfig();
		AudioConfigureJacks();
		LineinLineoutConfig();

		 XScuTimer_Config *Scu_ConfigPtr;

		 Scu_ConfigPtr = XScuTimer_LookupConfig(XPAR_PS7_SCUTIMER_0_DEVICE_ID);
		 Status = XScuTimer_CfgInitialize(&Scu_Timer, Scu_ConfigPtr, Scu_ConfigPtr->BaseAddr);
		 Status = Timer_Intr_Setup(&IntcInstance, &Scu_Timer, XPS_SCU_TMR_INT_ID);
		 XScuTimer_LoadTimer(&Scu_Timer,(XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ / 2)/(SAMPLE_RATE));
		 XScuTimer_EnableAutoReload(&Scu_Timer);
		 XScuTimer_Start(&Scu_Timer);

		 (void)Status;
	}

	int
	Audio_Driver::Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId)
	{
		int Status;
		XScuGic_Config *IntcConfig;
		IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
		Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
		// Step 1: Interrupt Setup
		Xil_ExceptionInit();
		// Step 2: Interrupt Setup
		Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler,IntcInstancePtr);
		// Step 3: Interrupt Setup
		Status = XScuGic_Connect(IntcInstancePtr, TimerIntrId, (Xil_ExceptionHandler)Timer_ISR, (void *)TimerInstancePtr);
		// Step 4: Interrupt Setup
		XScuGic_Enable(IntcInstancePtr, TimerIntrId);
		// Step 5:
		XScuTimer_EnableInterrupt(TimerInstancePtr);
		// Step 6: Interrupt Setup
		Xil_ExceptionEnable();

		(void)Status;

		return XST_SUCCESS;
	}

	void
	Audio_Driver::Timer_ISR(void * CallBackRef)
	{

		//const float32_t frequency = 2222; //audio frequency to generate
		//const float32_t theta_increment = 2 * PI * frequency / SAMPLE_RATE;
		//static float32_t theta = 0.0f;

		XScuTimer *TimerInstancePtr = (XScuTimer *) CallBackRef;
		XScuTimer_ClearInterruptStatus(TimerInstancePtr);

		//theta += theta_increment ;
		//if ( theta > 2* PI)
		//	theta -= 2* PI;
		u32DataL = Xil_In32(I2S_DATA_RX_L_REG);
		u32DataR = Xil_In32(I2S_DATA_RX_R_REG);

		//float sine_value = sinf(theta); // non CMSIS function comment out for using
		//float32_t sine_value = arm_sin_f32(theta); // CMSIS function
		//uint32_t scaled_value = (uint32_t)(((sine_value + 1.0f) * 0.5f) * UINT_SCALED_MAX_VALUE);
		Xil_Out32(I2S_DATA_TX_R_REG, u32DataR);
		Xil_Out32(I2S_DATA_TX_L_REG, u32DataL);
	}
}

UART::UART(){
	XUartPs_Config *Config = XUartPs_LookupConfig(XPAR_XUARTPS_0_DEVICE_ID);
	XUartPs_CfgInitialize(&Uart_Ps, Config, Config->BaseAddress);
	XUartPs_SetBaudRate(&Uart_Ps, 115200);
}

Rotary_enc::Rotary_enc(){
	XGpio_Initialize(&rotary, XPAR_AXI_GPIO_0_DEVICE_ID);
	XGpio_SetDataDirection(&rotary, 1, 0xFFFFFFFF);  // all inputs
	PS = Getvalue();
}

Rotary_enc::RE_STATE
Rotary_enc::GetSate(){
	u32 CS = Getvalue();
	RE_STATE state{IDLE};

	if(CS == 0b111){
	   switch(PS){
	       case 0b110:
	        	if(debounce){
	        			debounce = 0;
	        	}else {
	        		debounce= 1;
	        		xil_printf("button\r\n");
	        		state = BUTTON;
	        	}
				break;

			case 0b011:
				I32increment(counter,1);
				xil_printf("rechts, %d\r\n",counter);
				state = RIGHT;
				break;

			case 0b101:
				I32decrement(counter,1);
				xil_printf("links, %d\r\n",counter);
				state = LEFT;
				break;

			default:
				break;
	        }
	}
	PS = CS;

	return state;
}

Switch_arr::Switch_arr(){
	XGpio_Initialize(&SW, XPAR_AXI_GPIO_1_DEVICE_ID);
	XGpio_SetDataDirection(&SW, 2, 0xFFFFF);
	u8 tmp = XGpio_DiscreteRead(&SW, 2);
	PS_[0] = tmp;
	PS_[1] = tmp;

}

u8
Switch_arr::SWx_State(u8 sw){
	if(sw > 3 || sw < 1 ) return 0;

	u8 tmp = XGpio_DiscreteRead(&SW, 2);

	CS_[sw] = ( tmp >> (sw-1) )& 0x1; // tmp =2 0b10 sw=2 0b10;


	if(PS_[sw] != CS_[sw]){
		switch(CS_[sw]){
		case 1:
				xil_printf("sw%u switch on\r\n",sw);
			break;
		case 0:
				xil_printf("sw%u switch off\r\n",sw);
			break;

		default:
			break;
		}
	}
	PS_[sw] = CS_[sw];
}

