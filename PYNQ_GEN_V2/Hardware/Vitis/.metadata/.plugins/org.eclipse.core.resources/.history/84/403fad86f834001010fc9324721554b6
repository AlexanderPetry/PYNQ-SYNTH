#include "platform.h"
#include "logic.h"

namespace audio{

#define float float32_t
#define UINT32_MAX_AS_FLOAT 4294967295.0f //(2^32 - 1
#define UINT_SCALED_MAX_VALUE 0xFFFFF // 2^24 =>24 bits audio codec maximum value is 0xFF FFFF

#define TIMER_DEVICE_ID		XPAR_XSCUTIMER_0_DEVICE_ID
#define INTC_DEVICE_ID		XPAR_SCUGIC_SINGLE_DEVICE_ID
#define TIMER_IRPT_INTR		XPAR_SCUTIMER_INTR
#define SAMPLE_RATE 		48000

class Audio_Driver{
public:
	static Audio_Driver& instance(){ static Audio_Driver AD; return AD; }
private:
	Audio_Driver();

	static void Timer_ISR(void * CallBackRef);
	static int Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId);

	XScuTimer Scu_Timer;
	XScuGic IntcInstance;
	static unsigned long u32DataL;
	static unsigned long u32DataR;
};

unsigned long Audio_Driver::u32DataL = 0;
unsigned long Audio_Driver::u32DataR = 0;

}

using namespace audio;

int main() {
	init_platform();

	UART uart{ UART::instance() };
	Audio_Driver audio{ Audio_Driver::instance()};
	Effects eff_instance{ Effects::instance() };

	eff_instance.traverseList();

    cleanup_platform();
    return 0;
}


namespace audio{

	Audio_Driver::Audio_Driver(){
		int Status;
		IicConfig(XPAR_XIICPS_0_DEVICE_ID);
		AudioPllConfig();
		AudioConfigureJacks();
		LineinLineoutConfig();

		 XScuTimer_Config *Scu_ConfigPtr;

		 Scu_ConfigPtr = XScuTimer_LookupConfig(XPAR_PS7_SCUTIMER_0_DEVICE_ID);
		 Status = XScuTimer_CfgInitialize(&Scu_Timer, Scu_ConfigPtr, Scu_ConfigPtr->BaseAddr);
		 Status = Timer_Intr_Setup(&IntcInstance, &Scu_Timer, XPS_SCU_TMR_INT_ID);
		 XScuTimer_LoadTimer(&Scu_Timer,(XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ / 2)/(SAMPLE_RATE));
		 XScuTimer_EnableAutoReload(&Scu_Timer);
		 XScuTimer_Start(&Scu_Timer);

		 (void)Status;
	}

	int
	Audio_Driver::Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId)
	{
		int Status;
		XScuGic_Config *IntcConfig;
		IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
		Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
		// Step 1: Interrupt Setup
		Xil_ExceptionInit();
		// Step 2: Interrupt Setup
		Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler,IntcInstancePtr);
		// Step 3: Interrupt Setup
		Status = XScuGic_Connect(IntcInstancePtr, TimerIntrId, (Xil_ExceptionHandler)Timer_ISR, (void *)TimerInstancePtr);
		// Step 4: Interrupt Setup
		XScuGic_Enable(IntcInstancePtr, TimerIntrId);
		// Step 5:
		XScuTimer_EnableInterrupt(TimerInstancePtr);
		// Step 6: Interrupt Setup
		Xil_ExceptionEnable();

		(void)Status;

		return XST_SUCCESS;
	}

	void
	Audio_Driver::Timer_ISR(void * CallBackRef)
	{
		XScuTimer *TimerInstancePtr = (XScuTimer *) CallBackRef;
		XScuTimer_ClearInterruptStatus(TimerInstancePtr);

		u32DataL = Xil_In32(I2S_DATA_RX_L_REG);
		//u32DataR = Xil_In32(I2S_DATA_RX_R_REG);
		Effects eff_instance{ Effects::instance() };

		eff_instance.perform(u32DataL);

		Xil_Out32(I2S_DATA_TX_R_REG, u32DataL);
		Xil_Out32(I2S_DATA_TX_L_REG, u32DataL);
	}
}
