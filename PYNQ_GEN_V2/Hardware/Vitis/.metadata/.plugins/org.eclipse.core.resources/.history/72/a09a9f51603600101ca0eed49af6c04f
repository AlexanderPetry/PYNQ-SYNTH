enum EffectType { NONE, ECHO, TREMOLO, DISTORTION, LOWPASS, BITCRUSH, REVERB};
EffectType currentEffect = NONE;

#define ECHO_BASE 0x40010000


//*********** ECHO effect **************//

float echo(float sample) {
    float delay_ms = 500.0f;
    float gain = 0.4f;
    int sample_rate = 44100;

    uint32_t s = *((uint32_t*)&sample);
    uint32_t d = *((uint32_t*)&delay_ms);
    uint32_t g = *((uint32_t*)&gain);

    Xil_Out32(ECHO_BASE + 0x10, s);             // sample_in
    Xil_Out32(ECHO_BASE + 0x18, d);             // delay_ms
    Xil_Out32(ECHO_BASE + 0x20, g);             // feedback_gain
    Xil_Out32(ECHO_BASE + 0x28, sample_rate);   // sample_rate

    while ((Xil_In32(ECHO_BASE + 0x00) & 0x4) == 0); // wait for ap_idle

    // Start the operation
    Xil_Out32(ECHO_BASE + 0x00, 0x01); // ap_start
    Xil_Out32(ECHO_BASE + 0x00, 0x00); // clear

    // Wait for ap_done
    while ((Xil_In32(ECHO_BASE + 0x00) & 0x2) == 0);

    // Read the result
    uint32_t out = Xil_In32(ECHO_BASE + 0x08);  // sample_out
    return *((float*)&out);
}


//*********** TREMOLO effect **************//

static float tremoloPhase = 0;
float tremolo(float sample, int sampleRate, float freq = 5.0f)
{
	tremoloPhase += 2.0f * M_PI * freq / sampleRate; // 5Hz
	if (tremoloPhase > 2.0f * M_PI) tremoloPhase -= 2.0f * M_PI;
	float lfo = 0.5f * (1.0f + sinf(tremoloPhase));
	sample *= lfo;
	return sample;
}

//*********** DISTORTION effect **************//

float distortion(float sample, float gain = 2.0f) {
    return tanhf(gain * sample);
}


//*********** LOWPASS effect **************//

float lowpass(float sample, float alpha = 0.1f) {
    static float prev = 0.0f;
    float filtered = alpha * sample + (1.0f - alpha) * prev;
    prev = filtered;
    return filtered;
}


//*********** BITCRUSH effect **************//

float bitcrush(float sample, int bitDepth = 4, int downsampleRate = 4) {
    static int count = 0;
    static float held = 0.0f;

    if (++count >= downsampleRate) {
        count = 0;
        float scale = powf(2, bitDepth - 1);
        held = roundf(sample * scale) / scale;
    }

    return held;
}


//*********** REVERB effect **************//

static float reverbBuffer[44100] = {0}; // 1 sec buffer
static int reverbIndex = 0;

float reverb(float sample) {
    // Tap delays at different offsets
    int tap1 = (reverbIndex + 4370) % 44100;
    int tap2 = (reverbIndex + 12345) % 44100;
    int tap3 = (reverbIndex + 19876) % 44100;

    float reverbSample =
        0.3f * reverbBuffer[tap1] +
        0.2f * reverbBuffer[tap2] +
        0.1f * reverbBuffer[tap3];

    float out = sample + reverbSample;

    // Store new sample with slight damping
    reverbBuffer[reverbIndex] = sample + 0.6f * reverbSample;

    reverbIndex = (reverbIndex + 1) % 44100;
    return out;
}
