#ifndef PERIPHERAL_H
#define PERIPHERAL_H

#include "xuartps.h"
#include "xgpio.h"
#include "stdio.h"
#include "../audio.h"

#include "xgpio.h"
#include "xparameters.h"
#include "sleep.h"
#include "xscugic.h"
#include "xscutimer.h"

#include "arm_math.h"
#include "arm_const_structs.h"

#define I32increment(v, a) \
    do { \
        if ((a) > 0 && (v) > INT_MAX - (a)) \
            (v) = INT_MAX; \
        else if ((a) < 0 && (v) < INT_MIN - (a)) \
            (v) = INT_MIN; \
        else \
            (v) += (a); \
    } while (0)

#define I32decrement(v, a) I32increment((v), -(a))

namespace audio{

#define float float32_t
#define UINT32_MAX_AS_FLOAT 4294967295.0f //(2^32 - 1
#define UINT_SCALED_MAX_VALUE 0xFFFFF // 2^24 =>24 bits audio codec maximum value is 0xFF FFFF

#define TIMER_DEVICE_ID		XPAR_XSCUTIMER_0_DEVICE_ID
#define INTC_DEVICE_ID		XPAR_SCUGIC_SINGLE_DEVICE_ID
#define TIMER_IRPT_INTR		XPAR_SCUTIMER_INTR
#define SAMPLE_RATE 		48000

class Audio_Driver{
public:
	static Audio_Driver& instance(){ static Audio_Driver AD; return AD; }
private:
	Audio_Driver();

	static void Timer_ISR(void * CallBackRef);
	static int Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId);

	XScuTimer Scu_Timer;
	XScuGic IntcInstance;
	static unsigned long u32DataL;
	static unsigned long u32DataR;
};

}

class Switch_arr{
public:
	enum RE_STATE{
			SW_LEFT = 0b10,
			SW_RIGHT = 0b01,
			SW_BOTH = 0b11,
			SW_IDLE = 0
		};
	u8 SWx_State(u8 sw);
	static Switch_arr& instance(){ static Switch_arr SWA; return SWA; }
private:
	Switch_arr();
	u8 PS_[2]{0,0};
	u8 CS_[2]{0,0};
	XGpio SW;
};
Switch_arr::Switch_arr(){
	XGpio_Initialize(&sw0, XPAR_AXI_GPIO_1_DEVICE_ID);
	XGpio_SetDataDirection(&sw0, 2, 0xFFFFF);
	PS_ = XGpio_DiscreteRead(&sw0, 2);
}
u8 SWx_State(u8 sw){
	CS_ = XGpio_DiscreteRead(&sw0, 2)

	if(PS_ != CS_){
		switch(CS_){
		case SW_LEFT:
			break;
		case SW_RIGHT:
			break;
		case SW_BOTH:
			break;
		case SW_IDLE:
			break;
		default:
			break;
		}
		if(CS_){
			xil_printf("switch on\r\n");
		}else if(){
		    xil_printf("switch off\r\n");
		}
	}
}

class UART{
public:
	static UART& instance(){ static UART uart; return uart; }
private:
	UART();
	XUartPs Uart_Ps;
};

class Rotary_enc{
public:
	enum RE_STATE{
		LEFT,
		RIGHT,
		BUTTON,
		IDLE
	};

	RE_STATE GetSate();
	u32 GetCounter(){return counter;}
	void SetCounter(u32 v){counter = v;}

	static Rotary_enc& instance(){static Rotary_enc RE; return RE; };
private:
	Rotary_enc();

	u32 Getvalue(){ return XGpio_DiscreteRead(&rotary, 1); }

	XGpio 	rotary;
	int 	counter{0};
	u8 		debounce{1};
	u32 	PS{0};
	u32 	CS{0};
};
#endif
