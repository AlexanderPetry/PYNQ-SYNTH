#include "logic.h"

Effects::Effects(){
	internal_delay_Vstr.buf = Sbuffer;
	//memset(internal_delay_Vstr.buf, 0, sizeof(float)*DELAY_BUF_SIZE);
}


void
Effects::traverseList(){
	constexpr u8 total_btns = 4;

	Rotary_enc Rot_enc{ Rotary_enc::instance() };
	Switch_arr SW_ARR{ Switch_arr::instance() };
	Button_Array BTN_ARR{ Button_Array::instance() };

	u8 btn_mask{0};//[btn1][btn2][btn3][btn4]
	u8 sw1{0};
	u16 idx{0};
	u8 displayed_message{0};
	while (1){
		sw1 = SW_ARR.SWx_State(2);
		if(sw1 != Switch_arr::RE_STATE::ON_Stable) continue;

		if (!displayed_message){
			__CLEAR_SCREEN__ xil_printf("currently hovered over effect [-- %s --]\r\n",effect_list[idx].EffName);
			displayed_message =1;
		}

		btn_mask = 0;
		//check for ON_Changed event on buttons
		for (u8 i = 1; i <= total_btns; ++i) {
		    btn_mask <<= 1;
		    if (BTN_ARR.BTNx_State(i) == Button_Array::RE_STATE::ON_Changed){
		        btn_mask |= 0x1;
		    }
		}

		//one of the buttons generated an event
		if (btn_mask & 0xF) {
			switch(btn_mask){
				case 1://[btn4
						idx = (idx + EFFECT_AMOUNT - 1) % EFFECT_AMOUNT; //circular rotation for effect list]
						__CLEAR_SCREEN__ xil_printf("decrementing effect list\r\n");
						xil_printf("currently hovered over effect [-- %s --]\r\n",effect_list[idx].EffName);
					break;
				case 2://[btn3]
					 	 xil_printf("nothing set for this keybind\r\n");
					break;
				case 4://[btn2]
						 __DEBOUNCE__
					 	 xil_printf("selecting effect from list\r\n");
					 	 effect_list[idx].effFunction(0.f, effect_list[idx].intVstr);
					 	 displayed_message =0;
					break;
				case 8://[btn1]
						idx = (idx + 1) % EFFECT_AMOUNT; //circular rotation for effect list
						__CLEAR_SCREEN__ xil_printf("incrementing effect list\r\n");
					 	 xil_printf("currently hovered over effect [-- %s --]\r\n",effect_list[idx].EffName);
					break;

				default:
					break;
			}

		}
		__UART_DELAY__
	}
}

SoundEffect::SoundEffect(const char* name_, Eff_CB cb, void* V_struct) : effFunction(cb), intVstr(V_struct) {
    strncpy(EffName, name_, sizeof(EffName));
    EffName[sizeof(EffName) - 1] = '\0';
}

float
raw_to_float(unsigned long sample) {
    int32_t s = (int32_t)(sample << 8) >> 8;  // sign-extend 24-bit to 32-bit
    return (float)s / 8388608.0f;  // 2^23 = 8388608, max positive value for signed 24-bit
}

unsigned long
float_to_raw(float sample) {
    if (sample > 1.f) sample = 1.f;
    else if (sample < -1.f) sample = -1.f;

    int32_t s = (int32_t)(sample * 8388607.f); // max positive 24-bit value
    return (unsigned long)(s & 0xFFFFFF);
}

unsigned long
Effects::perform(unsigned long audioIn){
	float sample = raw_to_float(audioIn);

	// Read delayed sample
	read_index = (buf_index + DELAY_BUF_SIZE - internal_delay_Vstr.delayidx) % DELAY_BUF_SIZE;
	float delayed_sample = Sbuffer[read_index];

	//Echo = input + delayed * feedback
	float echo_sample = sample + delayed_sample * internal_echo_Vstr.feedback;

	// Store echo back into buffer
	Sbuffer[buf_index] = echo_sample;

	// Advance buffer index
	buf_index = (buf_index + 1) % DELAY_BUF_SIZE;

	// Output (scaled)
	mixed = echo_sample * internal_gain_Vstr.gain;

	return float_to_raw(mixed);
}

void
echo_effect(float32_t sample, void* params){
	constexpr u8 total_btns = 4;

	Rotary_enc& Rot_enc{ Rotary_enc::instance() };
	Button_Array& BTN_ARR{ Button_Array::instance() };

	u8 btn_mask{0};
	echo_Vstr* paramptr{ (echo_Vstr*)params };
	echo_Vstr EVstr_CPY = *paramptr;

	s32 last_counter = Rot_enc.GetCounter();

	while(1){
		Rot_enc.GetSate();
		s32 current_counter = Rot_enc.GetCounter();
		s32 delta = current_counter - last_counter;
		last_counter = current_counter;

		if (delta != 0) {
			paramptr->feedback += 0.05f * delta;
		    if (acc_feedback < 0.0f) acc_feedback = 0.0f;
		    if (acc_feedback > 1.0f) acc_feedback = 1.0f;

		    paramptr->feedback = acc_feedback;
		    __CLEAR_SCREEN__ printf("Feedback = %f\r\n",acc_feedback);
		}

		btn_mask = 0;

		for (u8 i = 1; i <= total_btns; ++i) {
			btn_mask <<= 1;
			if (BTN_ARR.BTNx_State(i) == Button_Array::RE_STATE::ON_Changed){
				btn_mask |= 0x1;
			}
		}

		if (btn_mask & 0xF) {
			switch(btn_mask){
				case 1://[btn4
					break;

				case 2://[btn3]
					__CLEAR_SCREEN__ xil_printf("user discarted changes\r\n");
					*paramptr = EVstr_CPY;
					__DEBOUNCE__
					return; //idk will see if return value should be applied or static global or something

				case 4://[btn2]

					__CLEAR_SCREEN__ printf("Feedback confirmed = %f\r\n", paramptr->feedback);
					__DEBOUNCE__
					return;

				case 8://[btn1]
					break;

				default:
					break;
			}
		}

	__UART_DELAY__
	}
}

void
delay_effect(float32_t sample, void* params){
	constexpr u8 total_btns = 4;

	Rotary_enc& Rot_enc{ Rotary_enc::instance() };
	Button_Array& BTN_ARR{ Button_Array::instance() };

	u8 btn_mask{0};
	delay_Vstr* paramptr{ (delay_Vstr*)params };
	delay_Vstr DVstr_CPY = *paramptr;

	s32 last_counter = Rot_enc.GetCounter();
	float delay_ms{0};
	float acc_delay_idx = static_cast<float>(paramptr->delayidx);
	constexpr float samples_per_tick = 1000.0f;

	while(1){
		Rot_enc.GetSate();
		s32 current_counter = Rot_enc.GetCounter();
		s32 delta = current_counter - last_counter;
		last_counter = current_counter;

		if (delta != 0) {
			//paramptr->delayidx += static_cast<float>(delta) * 0.5f;
			acc_delay_idx += delta * samples_per_tick;
			if (acc_delay_idx < 0.0f) acc_delay_idx = 0.0f;
			if (acc_delay_idx > static_cast<float>(DELAY_BUF_SIZE - 1)) acc_delay_idx = static_cast<float>(DELAY_BUF_SIZE - 1);

			paramptr->delayidx = static_cast<size_t>(acc_delay_idx);
			delay_ms = (paramptr->delayidx * 1000.0f) / SAMPLE_RATE;
			 __CLEAR_SCREEN__ printf("Delay(ms)= %f\r\n", delay_ms);
		}

		btn_mask = 0;

		for (u8 i = 1; i <= total_btns; ++i) {
			btn_mask <<= 1;
			if (BTN_ARR.BTNx_State(i) == Button_Array::RE_STATE::ON_Changed){
				btn_mask |= 0x1;
			}
		}

		if (btn_mask & 0xF) {
			switch(btn_mask){
				case 1://[btn4
					break;

				case 2://[btn3]
					__CLEAR_SCREEN__ xil_printf("user discarted changes\r\n");
					*paramptr = DVstr_CPY;
					__DEBOUNCE__
					return; //idk will see if return value should be applied or static global or something

				case 4://[btn2]

					__CLEAR_SCREEN__ printf("Delay(ms) confirmed = %f\r\n", delay_ms);
					__DEBOUNCE__
					return;

				case 8://[btn1]
					break;

				default:
					break;
			}
		}

	__UART_DELAY__
	}
}

void
gain_effect(float32_t sample, void* params) {
	constexpr u8 total_btns = 4;
	Rotary_enc& Rot_enc{ Rotary_enc::instance() };
	Button_Array& BTN_ARR{ Button_Array::instance() };

	u8 btn_mask{0};

	//make copy of original if the user does not like the sound produced.
	gain_Vstr* paramptr{ (gain_Vstr*)params };
	gain_Vstr GVstr_CPY = *paramptr;

	s32 last_counter = Rot_enc.GetCounter();

	while(1){
		Rot_enc.GetSate();
		s32 current_counter = Rot_enc.GetCounter();
		s32 delta = current_counter - last_counter;
	    last_counter = current_counter;

	    if (delta != 0) {
	    	paramptr->gain += 0.05f * delta;
	    	if (paramptr->gain < 0) paramptr->gain = 0;
	    	if (paramptr->gain > 2) paramptr->gain = 2;

	    	//int int_part = (int)paramptr->gain;
	    	//int frac_part = (int)((paramptr->gain - int_part) * 100);

	    	__CLEAR_SCREEN__ printf("gain = %f\r\n", paramptr->gain);
	    }

		btn_mask = 0;
		//check for ON_Changed event on buttons
		for (u8 i = 1; i <= total_btns; ++i) {
			btn_mask <<= 1;
			if (BTN_ARR.BTNx_State(i) == Button_Array::RE_STATE::ON_Changed){
				btn_mask |= 0x1;
			}
		}

		if (btn_mask & 0xF) {
			switch(btn_mask){
				case 1://[btn4
					break;
				case 2://[btn3]
						__CLEAR_SCREEN__ xil_printf("user discarted changes\r\n");
						*paramptr = GVstr_CPY;
						__DEBOUNCE__
						return; //idk will see if return value should be applied or static global or something
					break;
				case 4://[btn2]
						__CLEAR_SCREEN__ printf("gain confirmed = %f\r\n", paramptr->gain);
						__DEBOUNCE__
						return;
					break;
				case 8://[btn1]
					break;
				default:
					break;
			}
		}
	__UART_DELAY__
	}
	//return sample * paramptr->gain;
}

namespace audio{

	unsigned long Audio_Driver::u32DataL = 0;
	unsigned long Audio_Driver::u32DataR = 0;

	Audio_Driver::Audio_Driver(){
		int Status;
		IicConfig(XPAR_XIICPS_0_DEVICE_ID);
		AudioPllConfig();
		AudioConfigureJacks();
		LineinLineoutConfig();

		 XScuTimer_Config *Scu_ConfigPtr;

		 Scu_ConfigPtr = XScuTimer_LookupConfig(XPAR_PS7_SCUTIMER_0_DEVICE_ID);
		 Status = XScuTimer_CfgInitialize(&Scu_Timer, Scu_ConfigPtr, Scu_ConfigPtr->BaseAddr);
		 Status = Timer_Intr_Setup(&IntcInstance, &Scu_Timer, XPS_SCU_TMR_INT_ID);
		 XScuTimer_LoadTimer(&Scu_Timer,(XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ / 2)/(SAMPLE_RATE));
		 XScuTimer_EnableAutoReload(&Scu_Timer);
		 XScuTimer_Start(&Scu_Timer);

		 (void)Status;
	}

	int
	Audio_Driver::Timer_Intr_Setup(XScuGic * IntcInstancePtr, XScuTimer *TimerInstancePtr, u16 TimerIntrId)
	{
		int Status;
		XScuGic_Config *IntcConfig;
		IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
		Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig->CpuBaseAddress);
		// Step 1: Interrupt Setup
		Xil_ExceptionInit();
		// Step 2: Interrupt Setup
		Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler,IntcInstancePtr);
		// Step 3: Interrupt Setup
		Status = XScuGic_Connect(IntcInstancePtr, TimerIntrId, (Xil_ExceptionHandler)Timer_ISR, (void *)TimerInstancePtr);
		// Step 4: Interrupt Setup
		XScuGic_Enable(IntcInstancePtr, TimerIntrId);
		// Step 5:
		XScuTimer_EnableInterrupt(TimerInstancePtr);
		// Step 6: Interrupt Setup
		Xil_ExceptionEnable();

		(void)Status;

		return XST_SUCCESS;
	}

	void
	Audio_Driver::Timer_ISR(void * CallBackRef)
	{
		XScuTimer *TimerInstancePtr = (XScuTimer *) CallBackRef;
		XScuTimer_ClearInterruptStatus(TimerInstancePtr);

		u32DataL = Xil_In32(I2S_DATA_RX_L_REG);

		Effects& eff_instance{ Effects::instance() };
		u32DataL = eff_instance.perform(u32DataL);

		Xil_Out32(I2S_DATA_TX_R_REG, 0);
		Xil_Out32(I2S_DATA_TX_L_REG, u32DataL);
	}
}
